<!DOCTYPE html>
<html>

<head>
    <title>Final Project</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        /* หน้าโหลด GIF */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }
    </style>
</head>

<body>
    <div id="loadingOverlay">
        <img src="https://macaronieiei.github.io/ComputerGraphic_FinalProject/Spinner@1x-1.0s-200px-200px.gif"
            alt="Loading..." />
    </div>
    <button id="resetBtn" style="position:absolute; top:10px; left:10px; z-index:1000;">Reset View</button>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>

    <script>
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // Scene + Camera
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-60, 30, 55);
        camera.lookAt(-30, 10, 0);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(-30, 10, 0);
        controls.update();

        // Light
        const ambient = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambient);

        // Flags
        let exrReady = false;
        let homeReady = false;
        let textInfoReady = false;
        let myImageReady = false;
        let nameTextReady = false;
        let majorTextReady = false;
        let uniTextReady = false;

        // Clickable objects
        const clickable = [];
        function addObj(mesh, pos, name, visible) {
            mesh.position.copy(pos);
            mesh.name = name;
            mesh.visible = visible;
            clickable.push(mesh);
            return mesh;
        }

        // --- Views ---
        const VIEWS = {
            textMyInfo: {
                pos: new THREE.Vector3(-16, 6, 60),
                tar: new THREE.Vector3(-26, 5, 55)
            }
        };

        // Load EXR
        const exrLoader = new THREE.EXRLoader();
        exrLoader.load('https://macaronieiei.github.io/ComputerGraphic_FinalProject/citrus_orchard_puresky_1k.exr', texture => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = envMap;
            scene.background = envMap;
            texture.dispose();
            pmremGenerator.dispose();
            exrReady = true;
            checkReady();
        });

        // Load GLB
        const GLB_loader = new THREE.GLTFLoader();
        const clock = new THREE.Clock();
        let mixer = null;

        //Main Home
        GLB_loader.load('https://macaronieiei.github.io/ComputerGraphic_FinalProject/animation_home.glb?t=' + Date.now(), gltf => {
            const homeModel = gltf.scene;

            homeModel.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        const oldMat = child.material;
                        child.material = new THREE.MeshStandardMaterial({
                            color: oldMat.color || new THREE.Color(0xffffff),
                            map: oldMat.map || null,
                            metalness: 1,
                            roughness: 0.5,
                            envMapIntensity: 2,
                            normalMap: oldMat.normalMap || null,
                            transparent: oldMat.transparent || false,
                            opacity: oldMat.opacity || 1
                        });
                    }
                }
            });

            homeModel.scale.set(0.1, 0.1, 0.1);
            homeModel.rotation.y = Math.PI / 2;
            homeModel.position.set(0, 0, 0);
            scene.add(homeModel);

            if (gltf.animations && gltf.animations.length) {
                mixer = new THREE.AnimationMixer(homeModel);
                gltf.animations.forEach((clip) => mixer.clipAction(clip).play());
            }
            homeReady = true;
            checkReady();
        });

        //Text My Info
        let textMyInfo = null; // 1. ประกาศ global
        GLB_loader.load('https://macaronieiei.github.io/ComputerGraphic_FinalProject/MyInformation.glb?t=' + Date.now(), gltf => {
            textMyInfo = gltf.scene;

            textMyInfo.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.name = "textMyInfo";
                    child.receiveShadow = true;
                    if (child.material) {
                        const oldMat = child.material;
                        child.material = new THREE.MeshStandardMaterial({
                            color: oldMat.color || new THREE.Color(0xffffff),
                            map: oldMat.map || null,
                            metalness: 1,
                            roughness: 0.05,
                            envMap: scene.environment,
                            envMapIntensity: 2,
                            normalMap: oldMat.normalMap || null,
                            transparent: oldMat.transparent || false,
                            opacity: oldMat.opacity || 1
                        });
                    }
                }
            });

            textMyInfo.scale.set(7, 7, 7);
            textMyInfo.position.set(-75, 30, 18.5);
            clickable.push(textMyInfo);
            scene.add(textMyInfo);

            // --- เพิ่มไฟหลัง textMyInfo โหลดเสร็จ ---
            const textLight = new THREE.SpotLight(0xffffff, 1.5);
            textLight.position.set(-50, 50, 50);
            textLight.angle = Math.PI / 6;
            textLight.penumbra = 0.3;
            textLight.decay = 2;
            textLight.distance = 200;
            textLight.castShadow = true;

            textLight.target = textMyInfo;
            scene.add(textLight);
            scene.add(textLight.target);

            textInfoReady = true;
            checkReady();
        });

        // --- Add Image ---
        let myImage = null;
        GLB_loader.load('https://macaronieiei.github.io/ComputerGraphic_FinalProject/MyImage.glb?t=' + Date.now(), gltf => {
            myImage = gltf.scene;

            myImage.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        const oldMat = child.material;
                        child.material = new THREE.MeshStandardMaterial({
                            color: oldMat.color || new THREE.Color(0xffffff),
                            map: oldMat.map || null,
                            metalness: 0,
                            roughness: 1,
                            envMapIntensity: 1,
                            normalMap: oldMat.normalMap || null,
                            transparent: oldMat.transparent || false,
                            opacity: oldMat.opacity || 1
                        });
                    }
                }
            });

            myImage.scale.set(8, 8, 8);          // ปรับขนาดตามต้องการ
            myImage.position.set(-60, -12, 50);

            myImage.rotation.y = (Math.PI / 2) - 0.4; // หมุนขวา 90 องศ
            myImage.visible = false;
            scene.add(myImage);

            myImageReady = true;
            checkReady();

        });

        // --- Add Name Text ---
        let nameText = null;
        GLB_loader.load('https://macaronieiei.github.io/ComputerGraphic_FinalProject/name.glb?t=' + Date.now(), gltf => {
            nameText = gltf.scene;

            nameText.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        const oldMat = child.material;
                        child.material = new THREE.MeshStandardMaterial({
                            color: oldMat.color || new THREE.Color(0xffffff),
                            map: oldMat.map || null,
                            metalness: 1,
                            roughness: 0,
                            envMap: scene.environment,
                            envMapIntensity: 1,
                            normalMap: oldMat.normalMap || null,
                            transparent: oldMat.transparent || false,
                            opacity: oldMat.opacity || 1
                        });
                    }
                }
            });

            // ปรับขนาดและตำแหน่ง
            nameText.scale.set(50, 50, 50);             // ขนาดเล็กกว่า myImage
            nameText.position.set(-58, -2, 55);      // ตำแหน่งใกล้ myImage
            nameText.rotation.y = (Math.PI / 2) - 0.4; // หมุนเหมือน myImage
            nameText.visible = false;

            scene.add(nameText);

            nameTextReady = true; // ถ้ามี flag แบบ myImage
            checkReady();
        });

        // --- Add major Text ---
        let majorText = null;
        GLB_loader.load('https://macaronieiei.github.io/ComputerGraphic_FinalProject/major.glb?t=' + Date.now(), gltf => {
            majorText = gltf.scene;

            majorText.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        const oldMat = child.material;
                        child.material = new THREE.MeshStandardMaterial({
                            color: oldMat.color || new THREE.Color(0xffffff),
                            map: oldMat.map || null,
                            metalness: 1,
                            roughness: 0,
                            envMap: scene.environment,
                            envMapIntensity: 1,
                            normalMap: oldMat.normalMap || null,
                            transparent: oldMat.transparent || false,
                            opacity: oldMat.opacity || 1
                        });
                    }
                }
            });

            // ปรับขนาดและตำแหน่ง
            majorText.scale.set(20, 20, 20);             // ขนาดเล็กกว่า myImage
            majorText.position.set(-58, -8, 55);      // ตำแหน่งใกล้ myImage
            majorText.rotation.y = (Math.PI / 2) - 0.4; // หมุนเหมือน myImage
            majorText.visible = false;

            scene.add(majorText);

            majorTextReady = true; // ถ้ามี flag แบบ myImage
            checkReady();
        });

        // --- Add uni Text ---
        let uniText = null;
        GLB_loader.load('https://macaronieiei.github.io/ComputerGraphic_FinalProject/uni.glb?t=' + Date.now(), gltf => {
            uniText = gltf.scene;

            uniText.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        const oldMat = child.material;
                        child.material = new THREE.MeshStandardMaterial({
                            color: oldMat.color || new THREE.Color(0xffffff),
                            map: oldMat.map || null,
                            metalness: 1,
                            roughness: 0,
                            envMap: scene.environment,
                            envMapIntensity: 1,
                            normalMap: oldMat.normalMap || null,
                            transparent: oldMat.transparent || false,
                            opacity: oldMat.opacity || 1
                        });
                    }
                }
            });

            // ปรับขนาดและตำแหน่ง
            uniText.scale.set(20, 20, 20);             // ขนาดเล็กกว่า myImage
            uniText.position.set(-58, -20, 55);      // ตำแหน่งใกล้ myImage
            uniText.rotation.y = (Math.PI / 2) - 0.4; // หมุนเหมือน myImage
            uniText.visible = false;

            scene.add(uniText);

            uniTextReady = true; // ถ้ามี flag แบบ myImage
            checkReady();
        });


        function checkReady() {
            if (exrReady && homeReady && textInfoReady && myImageReady && nameTextReady && majorTextReady && uniTextReady ) {
                document.getElementById("loadingOverlay").style.display = "none";
                animate();
            }
        }

        // --- Camera & controls reset ---
        const initialCameraPos = camera.position.clone();
        const initialTarget = controls.target.clone();
        let resetting = false;

        document.getElementById('resetBtn').addEventListener('click', () => {
            resetting = true;

            if (textMyInfo) textMyInfo.visible = true;
            if (myImage) myImage.visible = false;
            if (nameText) nameText.visible = false;
            if (majorText) majorText.visible = false;
            if (uniText) uniText.visible = false;
        });


        // --- Raycaster ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let moveCamera = false;
        const targetCameraPos = new THREE.Vector3();
        const targetControls = new THREE.Vector3();

        function setPointer(e) {
            const r = renderer.domElement.getBoundingClientRect();
            pointer.x = ((e.clientX ?? e.touches[0].clientX) - r.left) / r.width * 2 - 1;
            pointer.y = -(((e.clientY ?? e.touches[0].clientY) - r.top) / r.height * 2 - 1);
        }

        function onClick(e) {
            setPointer(e);
            raycaster.setFromCamera(pointer, camera);
            const hit = raycaster.intersectObjects(clickable, true)[0];
            if (!hit) return;

            if (hit.object.name === "textMyInfo") {
                // ซ่อน textMyInfo
                if (textMyInfo) textMyInfo.visible = false;

                // ตั้งตำแหน่ง myImage ตรงกล้อง (เล็กน้อยด้านหน้า)
                if (myImage) myImage.visible = true;
                if (nameText) nameText.visible = true;
                if (majorText) majorText.visible = true;
                if (uniText) uniText.visible = true;

                // เคลื่อนกล้องไปตำแหน่ง view
                targetCameraPos.copy(VIEWS.textMyInfo.pos);
                targetControls.copy(VIEWS.textMyInfo.tar);
                moveCamera = true;
            }
        }


        renderer.domElement.addEventListener('click', onClick);

        // --- Animate ---
        function animate() {
            requestAnimationFrame(animate);

            // --- Move camera to target view ---
            if (moveCamera) {
                camera.position.lerp(targetCameraPos, 0.04);
                controls.target.lerp(targetControls, 0.04);
                controls.update();

                if (camera.position.distanceTo(targetCameraPos) < 0.04 &&
                    controls.target.distanceTo(targetControls) < 0.04) {
                    moveCamera = false;

        
                }
            }

            // --- Reset camera ---
            if (resetting) {
                camera.position.lerp(initialCameraPos, 0.04);
                controls.target.lerp(initialTarget, 0.04);
                controls.update();

                // ถ้ากล้องกลับถึงตำแหน่งเดิมแล้ว
                if (camera.position.distanceTo(initialCameraPos) < 0.04 &&
                    controls.target.distanceTo(initialTarget) < 0.04) {
                    camera.position.copy(initialCameraPos);
                    controls.target.copy(initialTarget);
                    controls.update();
                    resetting = false;
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>
